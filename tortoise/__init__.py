import asyncio
import importlib
import json
import logging
import os
import warnings
from inspect import isclass
from typing import Any, Coroutine, Dict, List, Optional, Type, Union

from pypika import Table

from tortoise.backends.base.client import BaseDBAsyncClient
from tortoise.backends.base.config_generator import expand_db_url, generate_config
from tortoise.exceptions import ConfigurationError
from tortoise.fields.relational import (
    BackwardFKRelation,
    BackwardOneToOneRelation,
    ForeignKeyField,
    ManyToManyField,
    OneToOneField,
    RelationField)

from tortoise.models import Model
from tortoise.queryset import QuerySet
from tortoise.transactions import current_transaction_map
from tortoise.utils import generate_schema_for_client

try:
    from contextvars import ContextVar
except ImportError:  # pragma: nocoverage
    from aiocontextvars import ContextVar  # type: ignore

logger = logging.getLogger("tortoise")


class Tortoise:
    app_models_map: Dict[str, Dict[str, Type[Model]]] = {}
    _connections: Dict[str, BaseDBAsyncClient] = {}
    _inited: bool = False

    @classmethod
    def get_connection(cls, connection_name: str) -> BaseDBAsyncClient:
        """
        Returns the connection by name.

        :raises KeyError: If connection name does not exist.
        """
        return cls._connections[connection_name]

    @classmethod
    def describe_model(cls, model: Type[Model], serializable: bool = True) -> dict:
        """
        Describes the given list of models or ALL registered models.

        :param model:
            The Model to describe

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serialisable data. (Defaults to ``True``)

        :return:
            A dictionary containing the model description.

            The base dict has a fixed set of keys that reference a list of fields
            (or a single field in the case of the primary key):

            .. code-block:: python3

                {
                    "name":                 str     # Qualified model name
                    "app":                  str     # 'App' namespace
                    "table":                str     # DB table name
                    "abstract":             bool    # Is the model Abstract?
                    "description":          str     # Description of table (nullable)
                    "unique_together":      [...]   # List of List containing field names that
                                                    #  are unique together
                    "pk_field":             {...}   # Primary key field
                    "data_fields":          [...]   # Data fields
                }

            Each field is specified as follows
            (This assumes ``serializable=True``, which is the default):

            .. code-block:: python3

                {
                    "name":         str     # Field name
                    "field_type":   str     # Field type
                    "db_column":    str     # Name of DB column
                                            #  Optional: Only for pk/data fields
                    "raw_field":    str     # Name of raw field of the Foreign Key
                                            #  Optional: Only for Foreign Keys
                    "db_column_types": dict  # DB Field types for default and DB overrides
                    "python_type":  str     # Python type
                    "generated":    bool    # Is the field generated by the DB?
                    "auto_created": bool    # Is the field auto created by Tortoise?
                    "nullable":     bool    # Is the column nullable?
                    "unique":       bool    # Is the field unique?
                    "db_index":     bool    # Is the field indexed?
                    "default":      ...     # The default value (coerced to int/float/str/bool/null)
                    "description":  str     # Description of the field (nullable)
                }

            When ``serializable=False`` is specified some fields are not coerced to valid
            JSON types. The changes are:

            .. code-block:: python3

                {
                    "field_type":   Field   # The Field class used
                    "python_type":  Type    # The actual Python type
                    "default":      ...     # The default value as native type OR a callable
                }
        """

        def _type_name(typ) -> str:
            if typ.__module__ == "builtins":
                return typ.__name__
            return f"{typ.__module__}.{typ.__name__}"

        def model_name(model: Type[Model]) -> str:
            return f"{model._meta.app}.{model.__name__}"

        def type_name(typ: Any) -> Union[str, List[str]]:
            try:
                if issubclass(typ, Model):
                    return model_name(typ)
            except TypeError:
                pass

            try:
                return _type_name(typ)
            except AttributeError:
                return [_type_name(_typ) for _typ in typ]

        def default_name(default: Any) -> Optional[Union[int, float, str, bool]]:
            if isinstance(default, (int, float, str, bool, type(None))):
                return default
            if callable(default):
                return f"<function {default.__module__}.{default.__name__}>"
            return str(default)

        def describe_field(name: str) -> dict:
            # TODO: db_type
            field = model._meta.fields_map[name]
            field_type = getattr(field, "remote_model", field.field_type)
            desc = {
                "name": name,
                "field_type": field.__class__.__name__ if serializable else field.__class__,
                "db_column": field.db_column or name,
                "raw_field": None,
                "db_column_types": field.get_db_column_types(),
                "python_type": type_name(field_type) if serializable else field_type,
                "generated": field.generated,
                "auto_created": field.auto_created,
                "nullable": field.null,
                "unique": field.unique,
                "db_index": field.db_index or field.unique,
                "default": default_name(field.default) if serializable else field.default,
                "description": field.description,
            }

            # Delete db fields for non-db fields
            if not desc["db_column_types"]:
                del desc["db_column_types"]

            # Foreign Keys have
            if isinstance(field, (ForeignKeyField, OneToOneField)):
                del desc["db_column"]
                desc["raw_field"] = field.db_column
            else:
                del desc["raw_field"]

            # These fields are entierly "virtual", so no direct DB representation
            if isinstance(
                field, (ManyToManyField, BackwardFKRelation, BackwardOneToOneRelation,),
            ):
                del desc["db_column"]

            return desc

        return {
            "name": model_name(model),
            "app": model._meta.app,
            "table": model._meta.table,
            "abstract": model._meta.abstract,
            "description": model._meta.table_description or None,
            "unique_together": model._meta.unique_together or [],
            "pk_field": describe_field(model._meta.pk_attr),
            "fields": [describe_field(name) for name in model._meta.fields_map.keys()
                if name != model._meta.pk_attr]
        }

    @classmethod
    def describe_models(
        cls, models: Optional[List[Type[Model]]] = None, serializable: bool = True
    ) -> Dict[str, dict]:
        """
        Describes the given list of models or ALL registered models.

        :param models:
            List of models to describe, if not provided then describes ALL registered models

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serializable data. (Defaults to ``True``)

        :return:
            A dictionary containing the model qualifier as key,
            and the same output as ``describe_model(...)`` as value:

            .. code-block:: python3

                {
                    "models.User": {...},
                    "models.Permission": {...}
                }
        """

        if not models:
            models = []
            for models_map in cls.app_models_map.values():
                for model in models_map.values():
                    models.append(model)

        return {
            f"{model._meta.app}.{model.__name__}": cls.describe_model(model, serializable)
            for model in models
        }

    @classmethod
    def _init_relations(cls) -> None:
        for app_name, app_models_map in cls.app_models_map.items():
            for model in app_models_map.values():
                if not model._meta._inited:
                    model._meta._inited = True
                    if not model._meta.table:
                        model._meta.table = f"{app_name}_{model.__name__.lower()}"

                    field_objects = list(model._meta.fields_map.values())
                    for field in field_objects:
                        if isinstance(field, RelationField) and not field.auto_created:
                            field.create_relation()

                    model._meta.finalise_pk()

    @classmethod
    def _discover_client_class(cls, engine: str) -> BaseDBAsyncClient:
        # Let exception bubble up for transparency
        engine_module = importlib.import_module(engine)

        try:
            client_class = engine_module.client_class  # type: ignore
        except AttributeError:
            raise ConfigurationError(f'Backend for engine "{engine}" does not implement db client')
        return client_class

    @classmethod
    def _discover_models(cls, models_path: str, app_label: str) -> List[Type[Model]]:
        try:
            module = importlib.import_module(models_path)
        except ImportError:
            raise ConfigurationError(f'Module "{models_path}" not found')

        discovered_models = []
        possible_models = getattr(module, "__models__", None)

        try:
            possible_models = [*possible_models]
        except TypeError:
            possible_models = None

        if not possible_models:
            possible_models = [getattr(module, attr_name) for attr_name in dir(module)]

        for attr in possible_models:
            if isclass(attr) and issubclass(attr, Model) and not attr._meta.abstract:
                if attr._meta.app and attr._meta.app != app_label:
                    continue
                attr._meta.app = app_label
                attr._meta.finalise_pk()
                discovered_models.append(attr)

        if not discovered_models:
            warnings.warn(f'Module "{models_path}" has no models', RuntimeWarning, stacklevel=4)

        return discovered_models

    @classmethod
    async def _init_connections(cls, connections_config: dict, create_db: bool) -> None:
        for connection_name, conn_config in connections_config.items():
            if isinstance(conn_config, str):
                conn_config = expand_db_url(conn_config)

            client_class = cls._discover_client_class(conn_config.get("engine"))
            db_params = conn_config["credentials"].copy()
            db_params.update({"connection_name": connection_name})
            connection = client_class(**db_params)  # type: ignore

            if create_db:
                await connection.db_create()

            await connection.create_connection(with_db=True)
            cls._connections[connection_name] = connection
            current_transaction_map[connection_name] = ContextVar(connection_name, default=connection)

    @classmethod
    def _init_apps(cls, apps_config: dict) -> None:
        for app_name, app_config in apps_config.items():
            connection_name = app_config.get("default_connection", "default")
            try:
                cls.get_connection(connection_name)
            except KeyError:
                raise ConfigurationError(
                    'Unknown connection "{}" for app "{}"'.format(connection_name, app_name))

            app_models: List[Type[Model]] = []
            for module in app_config["models"]:
                app_models += cls._discover_models(module, app_name)

            for model in app_models:
                model._meta.default_connection = connection_name

            cls.app_models_map[app_name] = {model.__name__: model for model in app_models}

        cls._init_relations()
        cls._build_initial_querysets()

    @classmethod
    def _get_config_from_config_file(cls, config_file: str) -> dict:
        _, extension = os.path.splitext(config_file)
        if extension in (".yml", ".yaml"):
            import yaml  # pylint: disable=C0415

            with open(config_file, "r") as f:
                config = yaml.safe_load(f)

        elif extension == ".json":
            with open(config_file, "r") as f:
                config = json.load(f)
        else:
            raise ConfigurationError(
                f"Unknown config extension {extension}, only .yml and .json are supported"
            )
        return config

    @classmethod
    def _build_initial_querysets(cls) -> None:
        for models_map in cls.app_models_map.values():
            for model in models_map.values():
                model._meta.finalise_model()
                model._meta.basetable = Table(model._meta.table)
                model._meta.basequery = model._meta.db.query_class.from_(model._meta.table)

    @classmethod
    async def init(
        cls,
        config: Optional[dict] = None,
        config_file: Optional[str] = None,
        _create_db: bool = False,
        db_url: Optional[str] = None,
        modules: Optional[Dict[str, List[str]]] = None,
    ) -> None:
        """
        Sets up Tortoise-ORM.

        You can configure using only one of ``config``, ``config_file``
        and ``(db_url, modules)``.

        Parameters
        ----------
        :param config:
            Dict containing config:

            Example
            -------

            .. code-block:: python3

                {
                    'connections': {
                        # Dict format for connection
                        'default': {
                            'engine': 'tortoise.backends.asyncpg',
                            'credentials': {
                                'host': 'localhost',
                                'port': '5432',
                                'user': 'tortoise',
                                'password': 'qwerty123',
                                'database': 'test',
                            }
                        },
                        # Using a DB_URL string
                        'default': 'postgres://postgres:qwerty123@localhost:5432/events'
                    },
                    'apps': {
                        'models': {
                            'models': ['__main__'],
                            # If no default_connection specified, defaults to 'default'
                            'default_connection': 'default',
                        }
                    }
                }

        :param config_file:
            Path to .json or .yml (if PyYAML installed) file containing config with
            same format as above.

        :param _create_db:
            If ``True`` tries to create database for specified connections,
            could be used for testing purposes.

        :param db_url:
            Use a DB_URL string. See :ref:`db_url`

        :param modules:
            Dictionary of ``key``: [``list_of_modules``] that defined "apps" and modules that
            should be discovered for models.

        Raises
        ------
        ConfigurationError
            For any configuration error
        """
        if cls._inited:
            await cls.close_connections()
            await cls._reset_apps()

        if int(bool(config) + bool(config_file) + bool(db_url)) != 1:
            raise ConfigurationError(
                'You should init either from "config", "config_file" or "db_url"'
            )

        if config_file:
            config = cls._get_config_from_config_file(config_file)

        if db_url:
            if not modules:
                raise ConfigurationError('You must specify "db_url" and "modules" together')
            config = generate_config(db_url, modules)

        if "connections" not in config:
            raise ConfigurationError('Config must define "connections" section')

        if "apps" not in config:
            raise ConfigurationError('Config must define "apps" section')

        connections_config = config["connections"]  # type: ignore
        apps_config = config["apps"]  # type: ignore
        logger.info(
            "Tortoise-ORM startup\n    connections: %s\n    apps: %s",
            str(connections_config),
            str(apps_config),
        )

        await cls._init_connections(connections_config, _create_db)
        cls._init_apps(apps_config)
        cls._inited = True

    @classmethod
    async def close_connections(cls) -> None:
        """
        Close all connections cleanly.

        It is required for this to be called on exit,
        else your event loop may never complete
        as it is waiting for the connections to die.
        """
        for connection in cls._connections.values():
            await connection.close()
        cls._connections = {}
        logger.info("Tortoise-ORM shutdown")

    @classmethod
    async def _reset_apps(cls) -> None:
        for models_map in cls.app_models_map.values():
            for model in models_map.values():
                model._meta.default_connection = None

        cls.app_models_map.clear()
        current_transaction_map.clear()

    @classmethod
    async def generate_schemas(cls, safe: bool = True) -> None:
        """
        Generate schemas according to models provided to ``.init()`` method.
        Will fail if schemas already exists, so it's not recommended to be used as part
        of application workflow

        Parameters
        ----------
        safe:
            When set to true, creates the table only when it does not already exist.
        """
        if not cls._inited:
            raise ConfigurationError("You have to call .init() first before generating schemas")
        for connection in cls._connections.values():
            await generate_schema_for_client(connection, safe)

    @classmethod
    async def _drop_databases(cls) -> None:
        """
        Tries to drop all databases provided in config passed to ``.init()`` method.
        Normally should be used only for testing purposes.
        """
        if not cls._inited:
            raise ConfigurationError("You have to call .init() first before deleting schemas")
        for connection in cls._connections.values():
            await connection.close()
            await connection.db_delete()
        cls._connections = {}
        await cls._reset_apps()


def run_async(coro: Coroutine) -> None:
    """
    Simple async runner that cleans up DB connections on exit.
    This is meant for simple scripts.

    Usage::

        from tortoise import Tortoise, run_async

        async def do_stuff():
            await Tortoise.init(
                db_url='sqlite://db.sqlite3',
                models={'models': ['app.models']}
            )

            ...

        run_async(do_stuff())
    """
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(coro)
    finally:
        loop.run_until_complete(Tortoise.close_connections())


__version__ = "0.15.9"
